\section{\texttt{Generator.hs}}

The module \texttt{Generator} is quite big, and full of technical details,
mostly related to working with names
\begin{lstlisting}[name=generator]
residuate :: Graph Conf -> Task
residuate tree = (expr, program) where
	(expr, program, _) = res nameSupply [] tree

res :: NameSupply -> [(Conf, Conf)] -> Graph Conf 
	-> (Conf, Program, NameSupply)
res ns mp (Node e Stop) = (e, Program [] [], ns)

res ns mp (Node (Ctr cname _) (Decompose ts)) = 
	(Ctr cname args, p1, ns1) where
		(args, p1, ns1) = res' ns mp ts

res ns mp (Node (Let (v, _) _) (Decompose ts)) = 
	(e2 // [(v, e1)], p1, ns1) where
		([e1, e2], p1, ns1) = res' ns mp ts

res (n:ns) mp (Node e (Transient t)) = 
	(fcall, Program ((FDef f1 vs body):fs) gs, ns1) where
		vs = vnames e
		f1 = "f" ++ (tail n)
		fcall = FCall f1 $ map Var vs
		(body, Program fs gs, ns1) = 
			res ns ((e, fcall) : mp) t

res (n:ns) mp (Node e (Variants cs)) = 
	(gcall, Program fs (newGs ++ gs), ns1) where
		vs@(pv:vs') = vnames e
		(vs_, vs'_) = 
			if (isRepeated pv e) && (isUsed pv cs) 
			then (pv:vs, vs) else (vs, vs')
		g1 = "g" ++ (tail n)
		gcall = GCall g1 $ map Var vs_
		(bodies, Program fs gs, ns1) = 
			res' ns ((e, gcall) : mp) $ map snd cs
		pats = [pat | (Contract v pat, _) <- cs]
		newGs = [GDef g1 p vs'_ b | 
				 (p, b) <-  (zip pats bodies)]
		isUsed vname cs = 
			any (any (== vname) . vnames . nodeLabel . snd) 
				cs

res ns mp (Node e (Fold (Node base _) ren)) = 
	(call, Program [] [], ns) where
		call = baseCall // [(x, Var y) | (x, y) <- ren]
		Just baseCall = lookup base mp

res' :: NameSupply -> [(Conf, Conf)] -> [Graph Conf] 
	-> ([Conf], Program, NameSupply)
res' ns mp ts = foldl f ([], Program [] [], ns) ts where
	f (cs, Program fs gs, ns1) t = 
		(cs ++ [g], Program (fs ++ fs1) (gs ++ gs1), ns2) 
		where
			(g, Program fs1 gs1, ns2) = res ns1 mp t

isBase e1 (Node _ (Decompose ts)) = 
	or $ map (isBase e1) ts
isBase e1 (Node _ (Variants cs)) = 
	or $ map (isBase e1 . snd) cs
isBase e1 (Node _ (Transient t)) = isBase e1 t
isBase e1 (Node _ (Fold (Node e2 _) _)) = e1 == e2
isBase e1 (Node e2 Stop) = False
\end{lstlisting}

\texttt{residuate} delegates the main part of the work to \texttt{res}, which processes 
the tree top-down, left-to-right.
The result of traversing each subtree is a new configuration and a program
(a list of indifferent and curious function definitions).
The main complication is to ensure a unique name for each
generated function.
A more detailed explanation would probably get too long.
The reader is rather invited to study directly the sources.
To aid understanding, we list the graph obtained for the KMP-test
from the main article, and then repeated the same graph
overlaid with the new generated configurations.

%\newpage
\input{figures/generator0}

%Просто граф.

%\newpage
\input{figures/generator}

In the last figure we again mark by the same color nodes, which are equal
up to renaming.
The upper part of each node contains the original configuration,
the lower part -- the new configuration generated by \texttt{res}.

\begin{lstlisting}[style=demo,escapechar=!]
ghci> let g = ...

-- demo24
ghci> residuate g
f1(s)
f1(s) = g2(s);
g2("") = False();
g2(v1:v2) = g3(v1, v2);
g3('A', v2) = g4(v2);
g3('B', v2) = f1(v2);
g4("") = False();
g4(v3:v4) = g5(v3, v4);
g5('A', v4) = f6(v4);
g5('B', v4) = f1(v4);
f6(v4) = g7(v4);
g7("") = False();
g7(v5:v6) = g8(v5, v6);
g8('A', v6) = f6(v6);
g8('B', v6) = True();
\end{lstlisting}